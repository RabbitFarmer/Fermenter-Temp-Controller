<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fermenter Chart</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/plotly.js-dist-min"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; background: #f6f6f6; }
    #chart-container { max-width: 1200px; margin: auto; background: #ffffff; border-radius: 4px; padding: 16px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
    #tempChart { height: 500px; }
    .controls { text-align: center; margin: 12px 0; }
    .controls input { width: 80px; margin-right: 12px; }
    .controls button { padding: 6px 16px; margin: 0 4px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
    .controls button:hover { background-color: #45a049; }
    .back-button { margin-top: 16px; text-align: center; }
    .back-button a { display: inline-block; padding: 10px 20px; text-decoration: none; color: white; background-color: green; border-radius: 5px; font-weight: bold; }
    .back-button a:hover { background-color: darkgreen; }
    .date-range { text-align: center; margin-top: 8px; font-size: 14px; color: #555; }
    @media print {
      .controls, .back-button { display: none; }
      body { background: white; margin: 0; }
    }
  </style>
</head>
<body>
  <h2 style="text-align: center;">Fermenter Temperature & Gravity</h2>
  <div class="controls">
    <button id="print">Print</button>
    {% if tilt_color == "Fermenter" %}
    <button id="export">Export CSV</button>
    {% endif %}
    <button id="dashboard">Dashboard</button>
    <span id="status"></span>
  </div>
  <div id="chart-container">
    <div id="tempChart"></div>
    <div id="date-range" class="date-range"></div>
  </div>

  <script>
    const tiltColor = "{{ tilt_color or '' }}";
    const chartTempMargin = {{ system_settings.get('chart_temp_margin', 1.0) }};
    {% if tilt_color == "Fermenter" %}
    const beerName = "Temperature Control";
    const batchName = "N/A";
    const brewId = "N/A";
    const recipeOg = null;
    const recipeFg = null;
    const actualOg = null;
    const fermentationComplete = false;
    {% else %}
    const beerName = "{{ tilt_cfg[tilt_color].beer_name or 'Unknown' }}";
    const batchName = "{{ tilt_cfg[tilt_color].batch_name or 'Unknown' }}";
    const brewId = "{{ tilt_cfg[tilt_color].brewid or 'Unknown' }}";
    const recipeOg = {{ tilt_cfg[tilt_color].get('recipe_og') or 'null' }};
    const recipeFg = {{ tilt_cfg[tilt_color].get('recipe_fg') or 'null' }};
    const actualOg = {{ tilt_cfg[tilt_color].get('actual_og') or 'null' }};
    const fermentationComplete = {{ 'true' if tilt_cfg[tilt_color].get('notification_state', {}).get('fermentation_completion_datetime') else 'false' }};
    {% endif %}
    
    async function loadData(limit = 3000) {
      document.getElementById('status').textContent = 'Loading data...';

      const url = `/chart_data/${encodeURIComponent(tiltColor)}?limit=${limit}`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch data');

        const json = await response.json();
        let dataPoints = json.points || [];
        
        // Normalize data points - handle legacy log format
        // Old logs have separate 'date' and 'time' fields instead of 'timestamp'
        dataPoints = dataPoints.map((p) => {
          let ts = p.timestamp;
          // If timestamp is missing, construct it from date and time
          if (!ts && p.date && p.time) {
            ts = `${p.date}T${p.time}Z`;
          }
          // Handle temp_f vs current_temp
          let temp = p.temp_f;
          if (temp === null || temp === undefined) {
            temp = p.current_temp;
          }
          return {
            ...p,
            timestamp: ts,
            temp_f: temp
          };
        });
        
        // Check if this is temperature control data
        const isTempControl = (tiltColor === 'Fermenter');
        
        const traces = [];
        
        // Temperature trace - for temp control, split by tilt color
        if (isTempControl) {
          // Group data points by tilt color
          const colorGroups = {};
          dataPoints.forEach((p) => {
            const color = p.tilt_color || 'Unknown';
            if (!colorGroups[color]) {
              colorGroups[color] = [];
            }
            colorGroups[color].push(p);
          });
          
          // Define color mapping for traces
          const colorMap = {
            'Black': '#000000',
            'Blue': '#0000FF',
            'Green': '#008000',
            'Orange': '#FFA500',
            'Pink': '#FFC0CB',
            'Purple': '#800080',
            'Red': '#FF0000',
            'Yellow': '#FFFF00',
            'Unknown': '#808080'
          };
          
          // Create a trace for each tilt color
          Object.keys(colorGroups).sort().forEach((color) => {
            const points = colorGroups[color];
            traces.push({
              x: points.map(p => p.timestamp),
              y: points.map(p => p.temp_f),
              mode: 'lines+markers',
              name: `${color} Tilt`,
              line: { color: colorMap[color] || '#808080', shape: 'spline', width: 3 },
              marker: { size: 4 },
              yaxis: 'y1',
              connectgaps: false,
            });
          });
        } else {
          // Original single temperature trace for regular tilt data
          const tempTrace = {
            x: dataPoints.map((p) => p.timestamp),
            y: dataPoints.map((p) => p.temp_f),
            mode: 'lines',
            name: 'Temperature (°F)',
            line: { color: 'blue', shape: 'spline', width: 3 },
            yaxis: 'y1',
            connectgaps: false,
          };
          traces.push(tempTrace);
        }
        
        // Calculate temperature range with margin
        const temps = dataPoints.map(p => p.temp_f).filter(t => t != null && !isNaN(t));
        let tempMin = Math.min(...temps);
        let tempMax = Math.max(...temps);
        let tempRange = null;
        if (temps.length > 0 && isFinite(tempMin) && isFinite(tempMax)) {
          // For temperature control, use a base range of 40-100F, expanding as needed
          if (isTempControl) {
            tempMin = Math.min(40, tempMin - chartTempMargin);
            tempMax = Math.max(100, tempMax + chartTempMargin);
          } else {
            tempMin = tempMin - chartTempMargin;
            tempMax = tempMax + chartTempMargin;
          }
          tempRange = [tempMin, tempMax];
        } else if (isTempControl) {
          // Default to 40-100F if no data points for temp control
          tempRange = [40, 100];
        }
        
        // Calculate x-axis range
        // For completed/archived fermentations: use actual data range
        // For active fermentations: start from first data point, extend to 30 days if needed
        let xAxisRange = null;
        if (dataPoints.length > 0) {
          const timestamps = dataPoints.map(p => new Date(p.timestamp)).filter(d => !isNaN(d.getTime()));
          if (timestamps.length > 0) {
            const minDate = new Date(Math.min(...timestamps));
            const maxDate = new Date(Math.max(...timestamps));
            const actualDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
            
            // Start from the first data point
            const rangeStart = minDate;
            
            // For active fermentations, extend end to 30 days minimum from start
            // For completed fermentations, use actual end date
            let rangeEnd;
            if (fermentationComplete) {
              rangeEnd = maxDate;
            } else {
              const thirtyDaysFromStart = new Date(rangeStart.getTime() + (30 * 24 * 60 * 60 * 1000));
              rangeEnd = new Date(Math.max(maxDate.getTime(), thirtyDaysFromStart.getTime()));
            }
            
            xAxisRange = [rangeStart.toISOString(), rangeEnd.toISOString()];
            
            // Update date range display (show the extended x-axis range, not just data range)
            const dateRangeEl = document.getElementById('date-range');
            if (dateRangeEl) {
              const options = { year: 'numeric', month: 'long', day: 'numeric' };
              const startStr = rangeStart.toLocaleDateString('en-US', options);
              const endStr = rangeEnd.toLocaleDateString('en-US', options);
              dateRangeEl.textContent = `${startStr} - ${endStr}`;
            }
          }
        }
        
        let layout;
        
        if (isTempControl) {
          // For temperature control, add heating/cooling markers instead of gravity
          
          // Filter events for markers
          const heatingOnEvents = dataPoints.filter(p => p.event === 'HEATING-PLUG TURNED ON');
          const heatingOffEvents = dataPoints.filter(p => p.event === 'HEATING-PLUG TURNED OFF');
          const coolingOnEvents = dataPoints.filter(p => p.event === 'COOLING-PLUG TURNED ON');
          const coolingOffEvents = dataPoints.filter(p => p.event === 'COOLING-PLUG TURNED OFF');
          
          // Heating ON markers (red triangles pointing up)
          if (heatingOnEvents.length > 0) {
            traces.push({
              x: heatingOnEvents.map(p => p.timestamp),
              y: heatingOnEvents.map(p => p.temp_f),
              mode: 'markers',
              name: 'Heating ON',
              marker: { color: 'red', size: 10, symbol: 'triangle-up' },
              yaxis: 'y1',
            });
          }
          
          // Heating OFF markers (pink triangles pointing down)
          if (heatingOffEvents.length > 0) {
            traces.push({
              x: heatingOffEvents.map(p => p.timestamp),
              y: heatingOffEvents.map(p => p.temp_f),
              mode: 'markers',
              name: 'Heating OFF',
              marker: { color: 'pink', size: 10, symbol: 'triangle-down' },
              yaxis: 'y1',
            });
          }
          
          // Cooling ON markers (blue squares)
          if (coolingOnEvents.length > 0) {
            traces.push({
              x: coolingOnEvents.map(p => p.timestamp),
              y: coolingOnEvents.map(p => p.temp_f),
              mode: 'markers',
              name: 'Cooling ON',
              marker: { color: 'blue', size: 10, symbol: 'square' },
              yaxis: 'y1',
            });
          }
          
          // Cooling OFF markers (light blue squares)
          if (coolingOffEvents.length > 0) {
            traces.push({
              x: coolingOffEvents.map(p => p.timestamp),
              y: coolingOffEvents.map(p => p.temp_f),
              mode: 'markers',
              name: 'Cooling OFF',
              marker: { color: 'lightblue', size: 10, symbol: 'square' },
              yaxis: 'y1',
            });
          }
          
          // Layout without gravity axis
          // Determine what controls are in use
          const heatingInUse = heatingOnEvents.length > 0 || heatingOffEvents.length > 0;
          const coolingInUse = coolingOnEvents.length > 0 || coolingOffEvents.length > 0;
          let controlsInUse = '';
          if (heatingInUse && coolingInUse) {
            controlsInUse = 'Heating and Cooling In Use';
          } else if (heatingInUse) {
            controlsInUse = 'Heating In Use';
          } else if (coolingInUse) {
            controlsInUse = 'Cooling In Use';
          }
          
          // Build subtitle with date range
          const dateRangeEl = document.getElementById('date-range');
          let dateRangeText = '';
          if (dateRangeEl && dateRangeEl.textContent) {
            dateRangeText = dateRangeEl.textContent;
          }
          
          let titleText = '<b style="font-size: 24px;">TEMPERATURE CONTROL ACTIVITY</b>';
          if (dateRangeText) {
            titleText += `<br><span style="font-size: 14px;">${dateRangeText}</span>`;
          }
          if (controlsInUse) {
            titleText += `<br><span style="font-size: 12px; font-weight: normal;">${controlsInUse}</span>`;
          }
          
          layout = {
            title: {
              text: titleText,
              font: { size: 20 },
            },
            xaxis: {
              title: 'Timestamp',
              titlefont: { size: 12 },
              gridcolor: '#eaf2f5',
              range: xAxisRange,
            },
            yaxis: {
              title: 'Temperature (°F)',
              titlefont: { color: 'blue', size: 12 },
              tickfont: { color: 'blue', size: 10 },
              gridcolor: '#eaf2f5',
              range: tempRange || [40, 100],
            },
            showlegend: true,
            legend: { orientation: 'h', x: 0.5, xanchor: 'center', y: -0.2 },
            margin: { l: 50, r: 50, t: 70, b: 80 },
          };
        } else {
          // For regular tilt data, include gravity
          const gravityTrace = {
            x: dataPoints.map((p) => p.timestamp),
            y: dataPoints.map((p) => parseFloat(p.gravity)), // Gravity as numeric values
            mode: 'lines',
            name: 'Gravity',
            line: { color: '#E69D00', shape: 'spline', width: 3 }, // Darker, bolder yellow
            yaxis: 'y2',
            connectgaps: false,
          };
          traces.push(gravityTrace);
          
          // Calculate gravity range with new logic:
          // Upper limit: max(recipe_og, actual_og) + 0.002
          // Lower limit: min(recipe_fg, minimum_historical_gravity) - 0.002
          const gravities = dataPoints.map(p => parseFloat(p.gravity)).filter(g => g != null && !isNaN(g));
          let gravityMin = gravities.length > 0 ? Math.min(...gravities) : 0.990;
          let gravityMax = gravities.length > 0 ? Math.max(...gravities) : 1.100;
          
          // Calculate upper limit
          let upperLimit = gravityMax;
          if (recipeOg !== null && !isNaN(parseFloat(recipeOg))) {
            upperLimit = Math.max(upperLimit, parseFloat(recipeOg));
          }
          if (actualOg !== null && !isNaN(parseFloat(actualOg))) {
            upperLimit = Math.max(upperLimit, parseFloat(actualOg));
          }
          upperLimit += 0.002;
          
          // Calculate lower limit
          let lowerLimit = gravityMin;
          if (recipeFg !== null && !isNaN(parseFloat(recipeFg))) {
            lowerLimit = Math.min(lowerLimit, parseFloat(recipeFg));
          }
          lowerLimit -= 0.002;
          
          let gravityRange = [lowerLimit, upperLimit];
          
          layout = {
            title: {
              text: `Fermenter Readings | ${beerName} | Batch: ${batchName} | BrewId: ${brewId}`,
              font: { size: 16 },
            },
            xaxis: {
              title: 'Timestamp',
              titlefont: { size: 12 },
              gridcolor: '#eaf2f5',
              range: xAxisRange,
            },
            yaxis: {
              title: 'Temperature (°F)',
              titlefont: { color: 'blue', size: 12 },
              tickfont: { color: 'blue', size: 10 },
              gridcolor: '#eaf2f5',
              range: tempRange || [32, 120],
            },
            yaxis2: {
              title: 'Gravity',
              titlefont: { color: '#E69D00', size: 12 },
              tickfont: { color: '#E69D00', size: 10 },
              overlaying: 'y',
              side: 'right',
              gridcolor: '#ffffff',
              range: gravityRange,
            },
            showlegend: true,
            legend: { orientation: 'h', x: 0.5, xanchor: 'center', y: -0.2 },
            margin: { l: 50, r: 50, t: 50, b: 50 },
          };
        }

        Plotly.newPlot('tempChart', traces, layout);
        document.getElementById('status').textContent = '';
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = 'Failed to load data.';
      }
    }

    document.getElementById('reload').addEventListener('click', () => {
      loadData(3000);
    });
    
    // Add print button functionality
    document.getElementById('print').addEventListener('click', () => {
      window.print();
    });
    
    // Add dashboard button functionality
    document.getElementById('dashboard').addEventListener('click', () => {
      window.location.href = '/';
    });
    
    // Add export functionality for temperature control
    {% if tilt_color == "Fermenter" %}
    document.getElementById('export').addEventListener('click', async () => {
      try {
        document.getElementById('status').textContent = 'Exporting data...';
        const response = await fetch('/export_temp_control_csv', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });
        if (!response.ok) throw new Error('Export failed');
        const result = await response.json();
        if (result.success) {
          document.getElementById('status').textContent = `Exported to ${result.filename}`;
        } else {
          document.getElementById('status').textContent = 'Export failed: ' + (result.error || 'Unknown error');
        }
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = 'Export failed';
      }
    });
    {% endif %}

    loadData();
  </script>
</body>
</html>